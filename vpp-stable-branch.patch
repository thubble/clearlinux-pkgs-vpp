Dave Wallace (3):
      build: export missing header files required by hicn_plugin
      vapi: Missing include file in vlib.api.vapi.h
      docs: update spelling word list and fix typos

Dzmitry Sautsa (1):
      dpdk: fix program vlans on ixgbevf

Fan Zhang (1):
      dpdk: improve rx burst count per loop

Florin Coras (1):
      tcp: update error counters in listen node

Gabriel Oginski (1):
      ipsec: fix vector after remove entry in spd

Mauro Sardara (2):
      memif: fix memif_process_desc indexing
      udp: fix inner packet checksum calculation in udp-encap

Nathan Skrzypczak (1):
      memif: Fix underflow

Ofer Heifetz (1):
      tls: do not overwrite config parameters if set

diff --git a/MAINTAINERS b/MAINTAINERS
index e89f1aa29..f5f68e65c 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -42,6 +42,7 @@ Sphinx Documents
 I:	docs
 M:	John DeNisco <jdenisco@cisco.com>
 M:	Ray Kinsella <raykinsella78@gmail.com>
+M:	Dave Wallace <dwallacelf@gmail.com>
 F:	docs/
 
 Infrastructure Library
diff --git a/docs/spelling_wordlist.txt b/docs/spelling_wordlist.txt
index 53f34c50f..2e39e2b83 100644
--- a/docs/spelling_wordlist.txt
+++ b/docs/spelling_wordlist.txt
@@ -1,757 +1,247 @@
-AArch
-ACK
-ACL
-ACLs
-API
-ASan
-Aarch
-Agg
-Ajourn
-Ananyev
-govpp
-unserialization
-archs
-symlink
-libmemf
-libme
-mif
-pwait
-tunnelling
-ctx
-efd
-optimised
-strerror
-syscall
-ligato
-congruential
-phc
-Anycast
-Arp
-icmpr
-pps
-bc
-midchain
-Midchain
-fmt
-intfcs
-libmemifs
-gethostbyname
-multithreading
-sourceNATing
-Mapp
-Headend
-pgm
-retransmits
-cheng
-iccrg
-filsfils
-Datagram
-syscalls
-Altivec
-memcpy
-mmap
-Warshall
-XXhash
-headend
-Fortville
-openbsd
-zx
-openbsd
-Diffie
-github
-criterias
-daddr
-gettingstarted
-Arping
-Arping
-Autogenerated
-BGP
-adaptively
-Defensic
-aa
-BIHASH
-BV
-Backtrace
-allocatable
-consumability
-Usermode
-isn
-shouldn
-combinatorial
-ufwd
-Barach
-Bfd
-receival
-ap
-Bihash
-emphasise
-Bihashes
-neighbouring
-Brockners
-LimitCORE
-eXtensible
-aabb
-aftr
-Recircs
-Bufmon
-iPv
-Builtinurl
-deallocation
-nonaddress
-CMakeLists
-CNat
-CPPFLAGS
-Castelino
-Centos
-efp
-preallocation
-Cisco
-Clib
-Cmake
-Cnat
-ufwd
-runit
-rulebase
-seatbelt
-iWARP
-strongswan
-unapplies
-subgraphs
-Codenomicon
-eeff
-unapply
-analyse
-Colour
-subdirectories
-Comms
-srcIP
-Config
-unreachables
-ager
-ConnectX
-str
-undirected
-Contiv
-reselects
-Coras
-unmanaged
-Coredumps
-Coverity
-Crypto
-Cryptodev
-DS
-DSR
-Dataplane
-Dataplanes
-Debuginfo
-Decapsulating
-Dest
-Diffs
-Distro
-Donley
-Doxygen
-Eifel
-Encaps
-Enqueueing
-Enums
-Erns
-Extranets
-FiB
-Flowprobe
-GByte
-GTP
-GbE
-Gbe
-Gbits
-Gbps
-Gbytes
-Geneve
-Gerrit
-GigE
-Gigabit
-Github
-Goncalves
-Gzip
-HQoS
-Heapsize
-Hotkeys
-Huawei
-Hypervisors
-IBverbs
-IKEv2
-IP
-IPsec
-IPv
-IPv4
-Ikev
-Init
-Instantiation
-Integrations
-Interoperation
-Iperf
-Jira
-KMG
-KOC
-KVP
-programmability
-decapsulate
-pseudocode
-libsrtp
-upf
-Konstantynowicz
-Kube
-Kubeadm
-Kubelet
-Kubernetes
-L3XC
-LB
-LDFLAGS
-LLDP
-Linuxcon
-Lldp
-balancer
-balancers
-Lockless
-Loopback
-Lua
-encap
-Luajit
-MPLS
-MPLS
-Maciek
-Makefile
-Makefiles
-Manohar
-Maryam
-Mbytes
-Mdata
-Mellanox
-Memif
-Metadata
-Mfib
-Monroy
-Mpps
-Mss
-Multicast
-Multicore
-Multihoming
-Multiqueue
-Multistream
-Multitenancy
-Mutlithreading
-NIC
-llist
-NSH
-NUMA
-Namespace
-mrvl
-mempool
-localsids
-msgbuf
-logrotate
-auditd
-ndp
-neighbour
-modularity
-masse
-snapcraft
-tgz
-lcov
-cd
-gcovr
-ggcov
-Bn
-Cn
-unmounting
-sealert
-ausearch
-semodule
-Snapcraft
-multipass
-awk
-ldpreload
-iPerf
-xterms
-ps
-centos
-statfs
-proc
-unmounts
-unmount
-fs
-mountpoint
-statSocket
-Unmounting
-fusermount
-Golang
-setUp
-tearDown
-Stdout
-stdout
-testcase
-unittest
-TestVxlan
-UNUP
-pton
-infos
-papi
-setUpClass
-nelts
-portranges
-wasn
-wi
-xcrw
-xcrw
-xtr
-includedir
-iface
-realised
-interoperation
-Infiniband
-Inband
-woohoo
-inex
-inet
-instantiation
-libibverb
-lc
-jitter
-incrementing
-libvppapiclient
-linearization
-recurse
-recirc
-teib
-th
-srcPortDefinition
-srcUP
-ssm
-spinlock
-te
-recode
-srh
-stderr
-sha
-sys
-conn
-sv
-iWARP
-et
-handoffdemo
-syscfg
-hbh
-timebase
-gtp
-fbfc
-tmpl
-preprocessor
-fixup
-psp
-fmask
-extranet
-spd
-DT
-DX
-undefine
-aren
-subgraph
-expander
-encaps
-backwalk
-ccdd
-cdbdec
-centric
-cdba
-cfd
-cksum
-reallocations
-preload
-reachability
-rdtsc
-putatively
-ppc
-pitr
-pmtu
-rekeying
-requeueing
-requeued
-recusive
-requeue
-resolvers
-recurse
-recurses
-ress
-rloc
-rr
-rxandtx
-runnable
-scrollbars
-scrollbar
-tw
-typedef
-wouldn
-zeroize
-untagged
-upstreamed
-vectorized
-vfr
-vtf
-pbb
-petr
-peerings
-pathname
-pipelined
-parsable
-parallelize
-parallelizes
-pipelining
-netdev
-noevaluate
-onlink
-outacl
-preallocated
-nexthop
-nosyslog
-nthrottle
-nsess
-Neighbour
-nbr
-nd
-musdk
-muppet
-makefile
-mult
-Netmap
-Netplan
-mdata
-mroute
-Nsh
-Nstrings
-NxN
-loopId
-macos
-O'Driscoll
-OAM
-Oddbuf
-Openssl
-subnets
-Optimisations
-PCI
-PSP
-Pcap
-Perfmon
-Performan
-Pfister
-Plugin
-Plugins
-Pnat
-PoC
-Policers
-Pollable
-Preallocate
-Prebuilt
-Promisc
-Pseudocode
-Qemu
-QoS
-rss
-strongSwan
-Quic
-verifier
-Quickstart
-Load
-RLOC
-Reass
-uri
-alg
-resync
-pnat
-membulk
-uRPF
-vr
-proto
-pmc
-macip
-unthrottle
-liveness
-sa
-snat
-vss
-uncomment
-Rebase
-tmpfile
-url
-lt
-eid
-itr
-rlocs
-vip
-vips
-flowtable
-lcp
-rawhtml
-myhugosite
-www
-Redhat
-javascript
-Refactor
-Refactored
-subdirectory
-Responder
-shortcodes
-shortcode
-Roadmap
-Roto
-SCHED_RR
-hugo
-SRTP
-SRv
-SRv6
-Scapy
-Shamir
-Shrikant
-Slideshow
-Specialisations
-Srmpls
-Srv
-Stateful
-Strongswan
-Subnet
-Subnets
-Sw
-Syslog
-Systemd
-TLS
-TPv
-TRex
-Tahhan
-Tahr
-Templated
-Tenant
-Terabit
-Terraform
-Timebase
-Tollet
-Tracedump
-Tsou
-Tunnelling
-UDP
-Unformat
-Uninstall
-Uninstalling
-Unittest
-Urpf
-Usergroup
-Userspace
-VM
-VMs
-VMware
-VPP
-VPP
-VRF
-VRF
-Vagrantfile
-Vagrantfiles
-Valgrind
-Vbox
-Vhost
-Virtio
-Virtualization
-Vlib
-Vmxnet
-Vnet
-Vpp
-Vppinfra
-Vrrp
-Vswitch
-Vxlan
-Warnicke
-Webinar
-Wiki
-Wikipedia
-Wireguard
-Wireshark
-Wl
-Workstream
-XXX
-Xenial
-Xeon
-Xerus
-Xtensa
-Yaml
-Zhao
+aa
+aabb
 aarch
+Aarch
+AArch
 abf
 accelera
+ACK
 acl
+ACL
+ACLs
 acyclic
+adaptively
 addr
+adjacencies
 adl
 admin
 af
+aftr
+ager
+Agg
+Ajourn
 al
+alg
 alloc
+allocatable
 allocator
 allowlist
+Altivec
 amine
+analyse
+Ananyev
 ansi
+Anycast
+ap
+ap
 api
+API
+apis
 apiTrace
 app
 apps
+archs
+aren
 arg
 args
 arp
+Arp
 arping
+Arping
+Arping
+ASan
 async
 atomics
+auditd
+ausearch
 auth
 autoconf
 autoconfig
 autoconfiguration
 autodetect
+Autogenerated
 automake
 autoreconf
 autotools
 avf
 avl
 avx
+awk
 ba
 backend
 backends
+backpressure
 backtrace
+Backtrace
 backtracing
+backwalk
+balancer
+balancers
+Barach
 baseva
+bb
+bc
 bd
 behaviour
 bfd
+Bfd
+BGP
 bift
 bigly
 bihash
 bihash
+Bihash
+BIHASH
+Bihashes
 binutils
 bitmask
 bitzero
 blackholing
 blake
 bms
+Bn
 boolean
 bootup
+Brockners
 bsid
 bss
 bufferindex
 bufmon
+Bufmon
 bugfixing
 buildingrst
 builtin
 builtinurl
+Builtinurl
 busybox
+BV
 bvi
 byteswap
-cPython
 cacheline
+callees
+Castelino
 ccache
+ccdd
 ccmake
+cd
+cdba
+cdbdec
 cdp
 ce
+centos
+Centos
+centric
+cfd
 cfssl
+chachapoly
+cheng
 cisco
+Cisco
 cj
+cksum
 classful
 cli
 clib
+Clib
 cmake
+Cmake
+CMakeLists
 cmd
+Cn
+cnat
+Cnat
+CNat
+Codenomicon
+Colour
+combinatorial
+Comms
 condvar
 conf
 config
+Config
+configs
+congruential
+conn
 connectable
+ConnectX
+consumability
 contiv
+Contiv
+controlplane
 copwhitelist
 copwhtlistbase
+Coras
 coredump
-macswap
-datagrams
-plen
 coredumps
-refcount
+Coredumps
 corefile
 corefiles
-usecases
 corekeeper
 corelist
-fff
-middlebox
-backpressure
-ruleset
-lookups
-callees
-dstIP
-dstPortDefinition
-promisc
-netfilter
-multiprotocol
-pluggable
-eBPF
-libbpf
-hostname
-xffb
-lpc
-ec
-adjacencies
-neighbours
-pluggable
-lagrange
-reass
-lw
-desc
-dscp
-apis
-verboseness
-controlplane
-utilisation
-dsr
 coremask
 couldn
-mfib
-params
+Coverity
 cp
-ei
-det
 cpel
-decaps
-datapath
-daemontools
-daemonizing
-decapsulating
-decapsulated
 cpp
+CPPFLAGS
 cpu
+cPython
 crc
-syntaxes
-urpf
 crcs
+crit
+criterias
 crt
 crypto
+Crypto
 cryptodev
+Cryptodev
+cryptographic
 ctrl
 ctwo
+ctx
+daddr
+daemonizing
+daemontools
+Datagram
+datagrams
+datapath
 dataplane
+Dataplane
+Dataplanes
 datastructures
 dbg
 de
+deallocation
 debian
+debootstrap
 debuggability
+Debuginfo
 decap
+decaps
+decapsulate
+decapsulated
+decapsulating
+Decapsulating
 decapsulation
 declutters
+decrementing
+decrypt
+decrypted
+Defensic
 del
 demux
 demuxes
 dep
 depN
+deps
+dequeue
+deregister
+desc
 deselection
 dest
+Dest
+det
 dev
 devbind
 df
@@ -759,201 +249,289 @@ dhcp
 dhcp
 dhcpd
 dhcpserver
+dhcpv
+Diffie
+Diffs
 dir
 dirN
+disp
 distclean
 distro
+Distro
 distros
 dlsym
 dns
 dnsmasq
+Dockerfile
+dockerignore
 doesn
+Donley
 dont
+DoS
 doxygen
+Doxygen
+dpd
 dpdk
 dpkg
 dpo
 dport
 dryrun
+DS
+dscp
 dslite
+dsr
+DSR
 dst
+dstIP
+dstPortDefinition
+DT
 dumpxml
-eBGP
+DX
+e.g.
 eal
+eb
+eBGP
+eBPF
+ec
+ee
+eeff
+efd
+efp
+ei
+eid
+Eifel
 elog
 elogs
 elts
 emacs
 emerg
+emphasise
 enablement
 encap
+encap
+encaps
+Encaps
 endian
 enic
 enp
 enqueue
 enqueued
 enqueueing
+Enqueueing
 enqueues
+entrypoint
 enums
+Enums
 eos
 epoll
+Erns
+et
 etcd
+eth
 ethernet
 ethertype
 ethip
 eventfd
 evt
 executables
+expander
 extensibility
+eXtensible
+extranet
+Extranets
 failover
 fallback
 favour
 favoured
 favours
+fbfc
 fd
 fdioDocs
+fff
+FiB
 fifo
 fifos
 filesystem
+filsfils
+fixup
 flavours
 flowendns
 flowprobe
+Flowprobe
 flowstartns
+flowtable
+fmask
+fmt
 fn
 foo
 fooA
 fooB
 fooC
 foreach
+Fortville
+fs
+fusermount
+Gbe
+GbE
 gbit
-responder
-cryptographic
-tabula
-srv
-nsh
-xc
+Gbits
 gbp
+Gbps
+GByte
+Gbytes
 gcc
 gcov
-lxd
-testbed
-https
-configs
-zfs
-workspaces
-mss
-oddbuf
-srtp
-svs
-tlspicotls
-picotls
-respondhost
-initiatehost
-eth
-pem
-dhcpv
-subnet
-debootstrap
-sharepoint
-deps
+gcovr
 gdb
 ge
+geneve
+Geneve
 gerrit
+Gerrit
+gethostbyname
 gettingsources
+gettingstarted
+ggcov
 gid
-marvell
-lldp
-geneve
-openssl
-ipsecmb
-cnat
-xdp
-runtime
-ikev
-ioam
-http
-hs
-runtime
-DoS
-chachapoly
+Gigabit
+GigE
+github
+Github
 glibc
 gmake
-libc
-tracedump
-urpf
-wireguard
+Golang
+Goncalves
+govpp
 gpe
 gre
 grep
 grepping
 growable
 gso
+gtp
+GTP
 gtpu
 gud
 gui
+Gzip
 hairpinning
 handoff
+handoffdemo
 handoffs
 hashtable
+hbh
 hdr
+headend
+Headend
 heapsize
-hostNetwork
+Heapsize
+hostname
 hostnames
+hostNetwork
 hoststack
 hotkey
+Hotkeys
 hpp
 hqos
+HQoS
+hs
 hsa
+hsi
 html
 htop
+http
+https
+Huawei
 hugepage
 hugepages
 hugetlb
+hugo
 hw
 hyperlink
 hypervisor
-iACL
-iAcl
-iBGP
-iOAM
+Hypervisors
+i.e.
 ia
 iacl
+iAcl
+iACL
+iBGP
 ibverb
+IBverbs
+iccrg
 icmp
+icmpr
+ietf
+iface
 ifndef
 igb
 igmp
+ikev
+Ikev
+IKEv2
 ila
 imix
 inacl
+Inband
+includedir
+incrementing
 indices
 indicies
+inet
+inex
+Infiniband
+infos
 ing
 init
+Init
+initiatehost
 inline
 inlines
+instantiation
+Instantiation
+Integrations
 intel
 internet
+interoperation
+Interoperation
 interworkings
 intfc
+intfcs
 io
+ioam
+iOAM
 iommu
 ip
-ipN
-ipX
+IP
 ipaddress
 iperf
+iPerf
+Iperf
 ipfix
 ipip
+ipN
 ipsec
+IPsec
+ipsecmb
 iptables
 ipv
+iPv
+IPv
+IPv4
+ipX
 isc
+isn
 isra
 itf
 ith
+itr
+iWARP
+iWARP
 ixgbe
 ixge
+javascript
+Jira
+jitter
 jsmith
 jsmithuser
 json
@@ -963,358 +541,793 @@ kbps
 keepalives
 keychain
 kflows
+KMG
 kni
+KOC
+Konstantynowicz
 ksr
 kube
+Kube
 kubeadm
+Kubeadm
 kubectl
 kubelet
+Kubelet
 kubeproxy
 kubernetes
+Kubernetes
 kv
+KVP
+L3XC
 labelled
 lacp
+lagrange
+LB
+lc
+lcov
+lcp
 ld
+LDFLAGS
 ldp
+ldpreload
 learnt
 len
+libbpf
+libc
 libdir
 libfoo
+libibverb
+libme
+libmemf
 libmemif
+libmemifs
+libsrtp
 libvirt
+libvppapiclient
+ligato
+LimitCORE
+linearization
+linearize
 linting
 linux
 linuxapp
+Linuxcon
+liveness
+lldp
+Lldp
+LLDP
+llist
+Load
 localhost
 localsid
+localsids
+Lockless
+logrotate
 longjmp
+lookups
 loopback
+Loopback
+loopId
+lpc
 lshw
 lstack
+lt
 lua
+Lua
+Luajit
+lw
 lxc
-mFIB
-mIn
+lxd
+Maciek
+macip
+macos
+macswap
 mactime
+maglev
 mainp
+makefile
+Makefile
+Makefiles
 malloc
+Manohar
+Mapp
+marvell
+Maryam
+masse
 maximise
 mb
 mbedtls
 mbit
 mbufs
+Mbytes
 mc
 md
+mdata
+Mdata
+Mellanox
 mem
+membulk
+memcpy
 memfd
 memif
+Memif
+mempool
 metadata
+Metadata
 mf
+mfib
+mFIB
+Mfib
 mheap
+midchain
+Midchain
+middlebox
+mif
+mIn
 mispositions
 misprograms
 mk
 mldv
+mmap
 modelled
 modernisation
+modularity
+Monroy
 mortem
+mountpoint
 mpls
+MPLS
+MPLS
 mpps
+Mpps
+mroute
+mrvl
 msg
+msgbuf
+mss
+Mss
 mtrie
 mtu
+mult
 multiarch
 multicast
+Multicast
+Multicore
+Multihoming
+multipass
 multipath
+multiprotocol
 multiqueue
+Multiqueue
+Multistream
+Multitenancy
+multithreading
+muppet
+musdk
 mutex
+Mutlithreading
 myapp
 mygcc
+myhugosite
 myplugin
-nBackingPages
-nBytes
 namespace
+Namespace
 namespaces
 nat
+natively
 nats
 natted
+nBackingPages
+nbr
 nbytes
+nBytes
+nd
+ndp
 ndrpdr
+neighbour
+Neighbour
+neighbouring
+neighbours
+nelts
 netcfg
+netdev
+netfilter
 netlink
 netmap
+Netmap
 netplan
+Netplan
+nexthop
 nginx
+NIC
 nitems
+nl
 nn
 nnn
 nodaemon
+noevaluate
+nonaddress
+nosyslog
 ns
+nsess
+nsh
+Nsh
+NSH
 nsim
+Nstrings
+nthrottle
 nullptr
 num
 numa
+NUMA
+NxN
+O'Driscoll
 oacl
 oam
+OAM
+oddbuf
+Oddbuf
 offline
 ofr
 online
+onlink
 ooo
+openbsd
+openbsd
+openssl
+Openssl
 openSUSE
+operationalize
+Optimisations
+optimised
 os
+outacl
 packagecloud
+papi
+parallelize
+parallelizes
+param
+params
+parsable
 passthrough
 passwordless
+pathname
+pbb
 pcap
+Pcap
 pci
+PCI
 pe
+peerings
+pem
 perf
 perfmon
+Perfmon
+Performan
 perror
+petr
+Pfister
 pfSense
+pgm
+phc
 phoneycomponent
 physmem
+picotls
 pid
 pidfile
 pifi
+pipelined
+pipelining
+pitr
 pktgen
+plen
+pluggable
+pluggable
 plugin
+Plugin
 plugins
+Plugins
 pmalloc
+pmc
+pmtu
+pnat
+Pnat
+PoC
 podSubnet
 policer
+Policers
+Pollable
+portranges
 poweroff
+ppc
 pppoe
+pps
 pre
+Preallocate
+preallocated
+preallocation
+Prebuilt
 preceed
 preconfigured
 prefetch
 prefetching
+preload
 prepend
 prepended
+preprocessor
 printf
 priv
+proc
+programmability
 programme
 prometheus
+promisc
+Promisc
+proto
 proxying
+ps
+pseudocode
+Pseudocode
+psp
+PSP
 pthread
 pthreads
+pton
 pushingapatch
+putatively
+pwait
 py
 pypi
 qemu
+Qemu
 qos
+QoS
 qs
 qsz
 quic
+Quic
+Quickstart
 quicly
 rasa
+rawhtml
 rbtree
 rc
 rdma
-reStructured
-reStructuredText
+rdtsc
+reachability
 realcomponent
 realisation
 realise
+realised
+reallocations
 realsource
+reass
+Reass
+reassemblies
 rebase
+Rebase
+receival
+recirc
+Recircs
+recode
 recognised
+recurse
+recurse
+recurses
+recusive
+Redhat
 refactor
+Refactor
 refactored
+Refactored
+refcount
 regex
 reinjected
+rekeying
 repo
 repos
+requeue
+requeued
+requeueing
+reselects
+resolvers
+responder
+Responder
+respondhost
+ress
 restack
+reStructured
+reStructuredText
+resync
+retransmits
 rfc
 rint
+rloc
+RLOC
+rlocs
+Roadmap
+Roto
 rpath
+rr
 rsa
+rss
 rst
+rulebase
+ruleset
+runit
+runnable
+runtime
+runtime
 rwlocks
 rx
-sN
+rxandtx
+sa
 sbin
 scalable
 scanf
 scapy
+Scapy
+SCHED_RR
 sclass
 scooby
 screenshot
+scrollbar
+scrollbars
 sctp
+sealert
+seatbelt
 seg
 segfault
 selinux
+semodule
 setjmp
 settingupenvironment
+setUp
+setUpClass
 sfr
+sha
+Shamir
+sharepoint
 shg
 shm
+shortcode
+shortcodes
+shouldn
+Shrikant
 signalling
 sixrd
 sizeable
 sl
+Slideshow
+sN
+snapcraft
+Snapcraft
 snapshoot
+snat
 socketsvr
 socksvr
+sourceNATing
+spd
+Specialisations
+spinlock
 spinlocks
 sr
 src
+srcIP
+srcPortDefinition
+srcUP
+srh
+Srmpls
+srtp
+SRTP
+srv
+Srv
+SRv
+SRv6
 sshd
 ssl
+ssm
 stateful
+Stateful
+statfs
 statseg
+statSocket
+stderr
 stdin
+stdout
+Stdout
 stl
 stn
+str
+strerror
+strongswan
+strongSwan
+Strongswan
 struct
 su
+subdirectories
+subdirectory
 subfolder
 subfolders
+subgraph
+subgraphs
+subint
 subinterface
 subinterfaces
+subnet
+Subnet
+subnets
+Subnets
+substring
 sudo
+superset
+sv
 svm
+svs
 sw
+Sw
+symlink
+syntaxes
+sys
+syscall
+syscalls
+syscfg
 sysctl
 sysfs
 syslog
+Syslog
 systemd
+Systemd
 sz
+tabula
+Tahhan
+Tahr
 tapcli
 tcp
 tcpcontrolbits
+te
 teardown
+tearDown
 ted
+teib
+Templated
+Tenant
 tep
+Terabit
+Terraform
+testbed
+testbench
+testcase
+TestVxlan
+tgz
+th
 threadLeave
 threadplacement
 tid
+timebase
+Timebase
 timestamp
 tls
+TLS
 tlsmbedtls
 tlsopenssl
+tlspicotls
 tmp
+tmpfile
+tmpl
+Tollet
 toolchain
 toolchains
 tos
 tp
+tps
 tpv
+TPv
+tracedump
+Tracedump
+TRex
+Tsou
 ttl
+tunnelling
+Tunnelling
 tuntap
+tw
 twovppinstances
 tx
 txt
+typedef
 ubuntu
 udp
+UDP
+ufwd
+ufwd
 uid
 uio
 un
+unapplies
+unapply
+uncomment
+undefine
+undirected
 unformat
+Unformat
 unicast
 uninstall
+Uninstall
 uninstalled
+Uninstalling
+unittest
+Unittest
 unix
+unmanaged
+unmount
+unmounting
+Unmounting
+unmounts
+unreachables
 unrouteable
+unserialization
 unserialize
 unserializing
+untagged
 untaint
+unthrottle
+UNUP
 unwires
+upf
 upgradability
 upgradable
+upstreamed
+uri
+url
+urpf
+urpf
+uRPF
+Urpf
 usec
+usecases
 usergroup
+Usergroup
+Usermode
 username
 userspace
+Userspace
 usr
+utilisation
 uu
-vHost
-vRouter
-vRouters
-vSwitch
-vSwitches
-vTEP
 va
+Vagrantfile
+Vagrantfiles
+Valgrind
 vapi
+Vbox
 vcl
 ve
 vec
+vectorized
+verboseness
+verifier
 versioning
 veth
 vethQL
 vfctl
 vfio
+vfr
 vft
 vhost
+vHost
+Vhost
+vip
+vips
 virsh
 virtio
+Virtio
 virtualchnl
 virtualenv
 virtualization
+Virtualization
 virtualized
 vl
 vlan
 vlib
+Vlib
 vlibapi
 vlibmemory
 vls
 vm
+VM
+VMs
 vmware
+VMware
 vmx
 vmxnet
+Vmxnet
 vnet
-ap
+Vnet
 vom
 vpe
 vpn
 vpp
+Vpp
+VPP
+VPP
 vppapigen
 vppapitrace
 vppcapture
-bb
 vppctl
 vppinfra
+Vppinfra
 vpppinfra
 vpps
-crit
-eb
-ee
 vpptrace
+vr
 vrf
+VRF
+VRF
 vrouter
+vRouter
+vRouters
 vrrp
-decrementing
+Vrrp
+vss
 vswitch
+vSwitch
+Vswitch
 vswitches
+vSwitches
+vTEP
+vtf
 vxlan
+Vxlan
 walkthrough
-dequeue
-dpd
-disp
+Warnicke
+Warshall
+wasn
+Webinar
 webpage
-substring
-decrypted
-decrypt
-deregister
-superset
 whitelist
 whitelisting
 whitelists
+wi
 wiki
-ietf
+Wiki
+Wikipedia
+wireguard
+Wireguard
 wireshark
-xFFFFFFFF
-xTR
+Wireshark
+Wl
+woohoo
+workspaces
+Workstream
+wouldn
+www
+xc
 xchain
 xconnect
+xcrw
+xcrw
+xdp
+Xenial
+Xeon
+Xerus
+xffb
+xFFFFFFFF
+Xtensa
+xterms
+xtr
+xTR
+XXhash
 xxx
+XXX
 xyz
 yaml
+Yaml
 yyy
+zeroize
+zfs
+Zhao
 zoomin
 zoomout
+zx
 Âµs
-e.g.
-i.e.
-operationalize
\ No newline at end of file
diff --git a/docs/usecases/vpp_testbench/index.rst b/docs/usecases/vpp_testbench/index.rst
index 744fa8647..f79bd7c90 100644
--- a/docs/usecases/vpp_testbench/index.rst
+++ b/docs/usecases/vpp_testbench/index.rst
@@ -10,7 +10,7 @@ back-and-forth (i.e. ICMP echo/ping requests and HTTP GET requests).
 The intent of this example is to provide a relatively simple example of
 connecting containers via VPP and allowing others to use it as a springboard of
 sorts for their own projects and examples. Besides Docker and a handful of
-common Linux command-line utlities, not much else is required to build this
+common Linux command-line utilities, not much else is required to build this
 example (due to most of the dependencies being lumped inside the containers
 themselves).
 
@@ -60,7 +60,7 @@ project.
   other scripts in this project. Intended to be sourced (i.e. not intended to
   be run directly). Some of the helper functions are used at run-time within
   the containers, while others are intended to be run in the default namespace
-  on the host operating system to help with run-time configuration/bringup of
+  on the host operating system to help with run-time configuration/bring up of
   the testbench.
 * ``Dockerfile.vpp_testbench``: used to build the various Docker images used in
   this project (i.e. so VPP, our test tools, etc.; are all encapsulated within
@@ -81,7 +81,7 @@ Getting Started
 ^^^^^^^^^^^^^^^
 
 First, we'll assume you are running on a Ubuntu 20.04 x86_64 setup (either on a
-bare metal host or in a virtual machine), and have acquirec a copy of the
+bare metal host or in a virtual machine), and have acquired a copy of the
 project files (either by cloning the VPP git repository, or duplicating them
 from :ref:`sec_file_listings_vpp_testbench`). Now, just run ``make``. The
 process should take a few minutes as it pulls the baseline Ubuntu Docker image,
@@ -96,11 +96,11 @@ can be cleaned-up via ``make stop``, and the whole process of starting,
 testing, stopping, etc.; can be repeated as needed.
 
 In addition to starting up the containers, ``make start`` will establish
-variaous types of links/connections between the two containers, making use of
+various types of links/connections between the two containers, making use of
 both the Linux network stack, as well as VPP, to handle the "plumbing"
 involved. This is to allow various types of connections between the two
 containers, and to allow the reader to experiment with them (i.e. using
-``vppctl`` to congfigure or trace packets going over VPP-managed links, use
+``vppctl`` to configure or trace packets going over VPP-managed links, use
 traditional Linux command line utilities like ``tcpdump``, ``iproute2``,
 ``ping``, etc.; to accomplish similar tasks over links managed purely by the
 Linux network stack, etc.). Later labs will also encourage readers to compare
@@ -177,4 +177,3 @@ entrypoint_server.sh
    :caption: entrypoint_server.sh
    :language: shell
    :linenos:
-
diff --git a/src/plugins/dpdk/device/driver.c b/src/plugins/dpdk/device/driver.c
index ed3d94c7e..7a2b3e7fb 100644
--- a/src/plugins/dpdk/device/driver.c
+++ b/src/plugins/dpdk/device/driver.c
@@ -55,11 +55,16 @@ static dpdk_driver_t dpdk_drivers[] = {
     .int_unmaskable = 1,
   },
   {
-    .drivers = DPDK_DRIVERS ({ "net_e1000_igb_vf", "Intel e1000 VF" },
-			     { "net_ixgbe_vf", "Intel 82599 VF" }),
+    .drivers = DPDK_DRIVERS ({ "net_e1000_igb_vf", "Intel e1000 VF" }),
     .interface_name_prefix = "VirtualFunctionEthernet",
     .use_intel_phdr_cksum = 1,
   },
+  {
+    .drivers = DPDK_DRIVERS ({ "net_ixgbe_vf", "Intel 82599 VF" }),
+    .interface_name_prefix = "VirtualFunctionEthernet",
+    .use_intel_phdr_cksum = 1,
+    .program_vlans = 1,
+  },
   {
     .drivers = DPDK_DRIVERS ({ "net_dpaa2", "NXP DPAA2 Mac" }),
     .interface_name_prefix = "TenGigabitEthernet",
diff --git a/src/plugins/dpdk/device/node.c b/src/plugins/dpdk/device/node.c
index d83fa35b1..3ae74e096 100644
--- a/src/plugins/dpdk/device/node.c
+++ b/src/plugins/dpdk/device/node.c
@@ -364,12 +364,13 @@ dpdk_device_input (vlib_main_t * vm, dpdk_main_t * dm, dpdk_device_t * xd,
   /* get up to DPDK_RX_BURST_SZ buffers from PMD */
   while (n_rx_packets < DPDK_RX_BURST_SZ)
     {
-      n = rte_eth_rx_burst (xd->port_id, queue_id,
-			    ptd->mbufs + n_rx_packets,
-			    DPDK_RX_BURST_SZ - n_rx_packets);
+      u32 n_to_rx = clib_min (DPDK_RX_BURST_SZ - n_rx_packets, 32);
+
+      n = rte_eth_rx_burst (xd->port_id, queue_id, ptd->mbufs + n_rx_packets,
+			    n_to_rx);
       n_rx_packets += n;
 
-      if (n < 32)
+      if (n < n_to_rx)
 	break;
     }
 
diff --git a/src/plugins/memif/node.c b/src/plugins/memif/node.c
index 1f636f2b3..ce9f95bc4 100644
--- a/src/plugins/memif/node.c
+++ b/src/plugins/memif/node.c
@@ -247,7 +247,7 @@ memif_process_desc (vlib_main_t *vm, vlib_node_runtime_t *node,
   u32 n_buffers = 0;
   u32 n_left = ptd->n_packets;
   u32 packet_len;
-  int i = 0;
+  int i = -1;
 
   /* construct copy and packet vector out of ring slots */
   while (n_left)
@@ -261,6 +261,7 @@ memif_process_desc (vlib_main_t *vm, vlib_node_runtime_t *node,
       dst_off = start_offset;
 
     next_slot:
+      i++; /* next descriptor */
       n_bytes_left = desc_len[i];
 
       packet_len += n_bytes_left;
@@ -287,9 +288,6 @@ memif_process_desc (vlib_main_t *vm, vlib_node_runtime_t *node,
 	  }
 	while (PREDICT_FALSE (n_bytes_left));
 
-      /* next descriptor */
-      i++;
-
       if (desc_status[i].next)
 	{
 	  src_off = 0;
@@ -557,7 +555,7 @@ memif_device_input_inline (vlib_main_t *vm, vlib_node_runtime_t *node,
 
       vlib_get_buffers (vm, ptd->buffers, buffer_ptrs, n_buffers);
 
-      for (i = 0; i < n_pkts - 8; i++)
+      for (i = 0; i + 8 < n_pkts; i++)
 	{
 	  clib_prefetch_load (desc_data[i + 8]);
 	  clib_prefetch_store (buffer_ptrs[i + 8]->data);
@@ -574,7 +572,7 @@ memif_device_input_inline (vlib_main_t *vm, vlib_node_runtime_t *node,
       u32 n_pkts = vec_len (ptd->copy_ops);
       co = ptd->copy_ops;
 
-      for (i = 0; i < n_pkts - 8; i++)
+      for (i = 0; i + 8 < n_pkts; i++)
 	{
 	  clib_prefetch_load (co[i + 8].data);
 	  b = vlib_get_buffer (vm, ptd->buffers[co[i].buffer_vec_index]);
diff --git a/src/vnet/CMakeLists.txt b/src/vnet/CMakeLists.txt
index 9e7e0aa71..f8bbcefac 100644
--- a/src/vnet/CMakeLists.txt
+++ b/src/vnet/CMakeLists.txt
@@ -679,6 +679,7 @@ list(APPEND VNET_MULTIARCH_SOURCES
 list(APPEND VNET_HEADERS
   udp/udp_error.def
   udp/udp.h
+  udp/udp_encap.h
   udp/udp_packet.h
   udp/udp_inlines.h
   udp/udp_local.h
@@ -1202,6 +1203,7 @@ list(APPEND VNET_SOURCES
 list(APPEND VNET_HEADERS
   fib/fib.h
   fib/fib_api.h
+  fib/fib_entry_track.h
   fib/ip4_fib.h
   fib/ip4_fib_8.h
   fib/ip4_fib_16.h
diff --git a/src/vnet/ip/lookup.c b/src/vnet/ip/lookup.c
index c2c4bae50..d048f94b0 100644
--- a/src/vnet/ip/lookup.c
+++ b/src/vnet/ip/lookup.c
@@ -552,7 +552,13 @@ VLIB_CLI_COMMAND (vlib_cli_show_ip6_command, static) = {
 /* *INDENT-OFF* */
 VLIB_CLI_COMMAND (ip_route_command, static) = {
   .path = "ip route",
-  .short_help = "ip route [add|del] [count <n>] <dst-ip-addr>/<width> [table <table-id>] via [next-hop-address] [next-hop-interface] [next-hop-table <value>] [weight <value>] [preference <value>] [udp-encap-id <value>] [ip4-lookup-in-table <value>] [ip6-lookup-in-table <value>] [mpls-lookup-in-table <value>] [resolve-via-host] [resolve-via-connected] [rx-ip4 <interface>] [out-labels <value value value>]",
+  .short_help = "ip route [add|del] [count <n>] <dst-ip-addr>/<width> [table "
+		"<table-id>] via [next-hop-address] [next-hop-interface] "
+		"[next-hop-table <value>] [weight <value>] [preference "
+		"<value>] [udp-encap <value>] [ip4-lookup-in-table <value>] "
+		"[ip6-lookup-in-table <value>] [mpls-lookup-in-table <value>] "
+		"[resolve-via-host] [resolve-via-connected] [rx-ip4 "
+		"<interface>] [out-labels <value value value>]",
   .function = vnet_ip_route_cmd,
   .is_mp_safe = 1,
 };
diff --git a/src/vnet/ipsec/ipsec_spd_policy.c b/src/vnet/ipsec/ipsec_spd_policy.c
index 85acf7aea..36405bd6d 100644
--- a/src/vnet/ipsec/ipsec_spd_policy.c
+++ b/src/vnet/ipsec/ipsec_spd_policy.c
@@ -217,7 +217,7 @@ ipsec_add_del_policy (vlib_main_t * vm,
 				spd->policies[policy->type][ii]);
 	if (ipsec_policy_is_equal (vp, policy))
 	  {
-	    vec_del1 (spd->policies[policy->type], ii);
+	    vec_delete (spd->policies[policy->type], 1, ii);
 	    ipsec_sa_unlock (vp->sa_index);
 	    pool_put (im->policies, vp);
 	    break;
diff --git a/src/vnet/tcp/tcp_input.c b/src/vnet/tcp/tcp_input.c
index 64b9334cb..ae426280b 100644
--- a/src/vnet/tcp/tcp_input.c
+++ b/src/vnet/tcp/tcp_input.c
@@ -2653,7 +2653,6 @@ tcp46_listen_inline (vlib_main_t *vm, vlib_node_runtime_t *node,
 
   while (n_left_from > 0)
     {
-      u32 error = TCP_ERROR_NONE;
       tcp_connection_t *lc, *child;
 
       /* Flags initialized with connection state after lookup */
@@ -2668,14 +2667,14 @@ tcp46_listen_inline (vlib_main_t *vm, vlib_node_runtime_t *node,
 				   thread_index);
 	  if (tc->state != TCP_STATE_TIME_WAIT)
 	    {
-	      error = TCP_ERROR_CREATE_EXISTS;
+	      tcp_inc_counter (listen, TCP_ERROR_CREATE_EXISTS, 1);
 	      goto done;
 	    }
 
 	  if (PREDICT_FALSE (!syn_during_timewait (tc, b[0], &tw_iss)))
 	    {
 	      /* This SYN can't be accepted */
-	      error = TCP_ERROR_CREATE_EXISTS;
+	      tcp_inc_counter (listen, TCP_ERROR_CREATE_EXISTS, 1);
 	      goto done;
 	    }
 
@@ -2685,7 +2684,7 @@ tcp46_listen_inline (vlib_main_t *vm, vlib_node_runtime_t *node,
 	  /* listener was cleaned up */
 	  if (!lc)
 	    {
-	      error = TCP_ERROR_NO_LISTENER;
+	      tcp_inc_counter (listen, TCP_ERROR_NO_LISTENER, 1);
 	      goto done;
 	    }
 	}
@@ -2695,7 +2694,7 @@ tcp46_listen_inline (vlib_main_t *vm, vlib_node_runtime_t *node,
 	tcp_lookup_connection (lc->c_fib_index, b[0], thread_index, is_ip4);
       if (PREDICT_FALSE (child->state != TCP_STATE_LISTEN))
 	{
-	  error = TCP_ERROR_CREATE_EXISTS;
+	  tcp_inc_counter (listen, TCP_ERROR_CREATE_EXISTS, 1);
 	  goto done;
 	}
 
@@ -2712,7 +2711,7 @@ tcp46_listen_inline (vlib_main_t *vm, vlib_node_runtime_t *node,
 
       if (tcp_options_parse (tcp_buffer_hdr (b[0]), &child->rcv_opts, 1))
 	{
-	  error = TCP_ERROR_OPTIONS;
+	  tcp_inc_counter (listen, TCP_ERROR_OPTIONS, 1);
 	  tcp_connection_free (child);
 	  goto done;
 	}
@@ -2742,7 +2741,7 @@ tcp46_listen_inline (vlib_main_t *vm, vlib_node_runtime_t *node,
 				 lc->c_thread_index, 0 /* notify */ ))
 	{
 	  tcp_connection_cleanup (child);
-	  error = TCP_ERROR_CREATE_SESSION_FAIL;
+	  tcp_inc_counter (listen, TCP_ERROR_CREATE_SESSION_FAIL, 1);
 	  goto done;
 	}
 
@@ -2750,12 +2749,11 @@ tcp46_listen_inline (vlib_main_t *vm, vlib_node_runtime_t *node,
       child->tx_fifo_size = transport_tx_fifo_size (&child->connection);
 
       tcp_send_synack (child);
+      n_syns += 1;
 
     done:
-
       b += 1;
       n_left_from -= 1;
-      n_syns += (error == TCP_ERROR_NONE);
     }
 
   tcp_inc_counter (listen, TCP_ERROR_SYNS_RCVD, n_syns);
diff --git a/src/vnet/tls/tls.c b/src/vnet/tls/tls.c
index 9cf10086a..6482d5d80 100644
--- a/src/vnet/tls/tls.c
+++ b/src/vnet/tls/tls.c
@@ -1315,8 +1315,11 @@ tls_init (vlib_main_t * vm)
   vec_validate (tm->rx_bufs, num_threads - 1);
   vec_validate (tm->tx_bufs, num_threads - 1);
 
-  tm->first_seg_size = 32 << 20;
-  tm->add_seg_size = 256 << 20;
+  if (!tm->first_seg_size)
+    tm->first_seg_size = 32 << 20;
+
+  if (!tm->add_seg_size)
+    tm->add_seg_size = 256 << 20;
 
   transport_register_protocol (TRANSPORT_PROTO_TLS, &tls_proto,
 			       FIB_PROTOCOL_IP4, ~0);
diff --git a/src/vnet/udp/udp_encap.c b/src/vnet/udp/udp_encap.c
index cb93adb8d..a0f5a50c2 100644
--- a/src/vnet/udp/udp_encap.c
+++ b/src/vnet/udp/udp_encap.c
@@ -47,8 +47,7 @@ static void
 udp_encap_restack (udp_encap_t * ue)
 {
   dpo_stack (udp_encap_dpo_types[ue->ue_ip_proto],
-	     fib_proto_to_dpo (ue->ue_ip_proto),
-	     &ue->ue_dpo,
+	     fib_proto_to_dpo (ue->ue_ip_proto), &ue->ue_dpo,
 	     fib_entry_contribute_ip_forwarding (ue->ue_fib_entry_index));
 }
 
@@ -325,12 +324,12 @@ udp_encap_fib_last_lock_gone (fib_node_t * node)
 }
 
 const static char *const udp4_encap_ip4_nodes[] = {
-  "udp4-encap",
+  "udp4o4-encap",
   NULL,
 };
 
 const static char *const udp4_encap_ip6_nodes[] = {
-  "udp4-encap",
+  "udp6o4-encap",
   NULL,
 };
 
@@ -345,12 +344,12 @@ const static char *const udp4_encap_bier_nodes[] = {
 };
 
 const static char *const udp6_encap_ip4_nodes[] = {
-  "udp6-encap",
+  "udp4o6-encap",
   NULL,
 };
 
 const static char *const udp6_encap_ip6_nodes[] = {
-  "udp6-encap",
+  "udp6o6-encap",
   NULL,
 };
 
diff --git a/src/vnet/udp/udp_encap.h b/src/vnet/udp/udp_encap.h
index b096e0f5c..648e3b59e 100644
--- a/src/vnet/udp/udp_encap.h
+++ b/src/vnet/udp/udp_encap.h
@@ -85,7 +85,7 @@ typedef struct udp_encap_t_
   /**
    * The second cacheline contains control-plane data
    */
-    CLIB_CACHE_LINE_ALIGN_MARK (cacheline1);
+  CLIB_CACHE_LINE_ALIGN_MARK (cacheline1);
 
   /**
    * linkage into the FIB graph
diff --git a/src/vnet/udp/udp_encap_node.c b/src/vnet/udp/udp_encap_node.c
index 5b9fc0bf3..1ebe79532 100644
--- a/src/vnet/udp/udp_encap_node.c
+++ b/src/vnet/udp/udp_encap_node.c
@@ -61,9 +61,9 @@ format_udp6_encap_trace (u8 * s, va_list * args)
 }
 
 always_inline uword
-udp_encap_inline (vlib_main_t * vm,
-		  vlib_node_runtime_t * node,
-		  vlib_frame_t * frame, int is_encap_v6)
+udp_encap_inline (vlib_main_t *vm, vlib_node_runtime_t *node,
+		  vlib_frame_t *frame, ip_address_family_t encap_family,
+		  ip_address_family_t payload_family)
 {
   vlib_combined_counter_main_t *cm = &udp_encap_counters;
   u32 *from = vlib_frame_vector_args (frame);
@@ -121,12 +121,13 @@ udp_encap_inline (vlib_main_t * vm,
 	  ue1 = udp_encap_get (uei1);
 
 	  /* Paint */
-	  if (is_encap_v6)
+	  if (encap_family == AF_IP6)
 	    {
 	      const u8 n_bytes =
 		sizeof (udp_header_t) + sizeof (ip6_header_t);
-	      ip_udp_encap_two (vm, b0, b1, (u8 *) & ue0->ue_hdrs,
-				(u8 *) & ue1->ue_hdrs, n_bytes, 0);
+	      ip_udp_encap_two (vm, b0, b1, (u8 *) &ue0->ue_hdrs,
+				(u8 *) &ue1->ue_hdrs, n_bytes, encap_family,
+				payload_family);
 	      if (PREDICT_FALSE (b0->flags & VLIB_BUFFER_IS_TRACED))
 		{
 		  udp6_encap_trace_t *tr =
@@ -147,9 +148,9 @@ udp_encap_inline (vlib_main_t * vm,
 	      const u8 n_bytes =
 		sizeof (udp_header_t) + sizeof (ip4_header_t);
 
-	      ip_udp_encap_two (vm, b0, b1,
-				(u8 *) & ue0->ue_hdrs,
-				(u8 *) & ue1->ue_hdrs, n_bytes, 1);
+	      ip_udp_encap_two (vm, b0, b1, (u8 *) &ue0->ue_hdrs,
+				(u8 *) &ue1->ue_hdrs, n_bytes, encap_family,
+				payload_family);
 
 	      if (PREDICT_FALSE (b0->flags & VLIB_BUFFER_IS_TRACED))
 		{
@@ -202,12 +203,12 @@ udp_encap_inline (vlib_main_t * vm,
 									b0));
 
 	  /* Paint */
-	  if (is_encap_v6)
+	  if (encap_family == AF_IP6)
 	    {
 	      const u8 n_bytes =
 		sizeof (udp_header_t) + sizeof (ip6_header_t);
-	      ip_udp_encap_one (vm, b0, (u8 *) & ue0->ue_hdrs.ip6, n_bytes,
-				0);
+	      ip_udp_encap_one (vm, b0, (u8 *) &ue0->ue_hdrs.ip6, n_bytes,
+				encap_family, payload_family);
 
 	      if (PREDICT_FALSE (b0->flags & VLIB_BUFFER_IS_TRACED))
 		{
@@ -222,8 +223,8 @@ udp_encap_inline (vlib_main_t * vm,
 	      const u8 n_bytes =
 		sizeof (udp_header_t) + sizeof (ip4_header_t);
 
-	      ip_udp_encap_one (vm, b0, (u8 *) & ue0->ue_hdrs.ip4, n_bytes,
-				1);
+	      ip_udp_encap_one (vm, b0, (u8 *) &ue0->ue_hdrs.ip4, n_bytes,
+				encap_family, payload_family);
 
 	      if (PREDICT_FALSE (b0->flags & VLIB_BUFFER_IS_TRACED))
 		{
@@ -248,37 +249,87 @@ udp_encap_inline (vlib_main_t * vm,
   return frame->n_vectors;
 }
 
-VLIB_NODE_FN (udp4_encap_node) (vlib_main_t * vm,
-				vlib_node_runtime_t * node,
-				vlib_frame_t * frame)
+VLIB_NODE_FN (udp4o4_encap_node)
+(vlib_main_t *vm, vlib_node_runtime_t *node, vlib_frame_t *frame)
 {
-  return udp_encap_inline (vm, node, frame, 0);
+  return udp_encap_inline (vm, node, frame, AF_IP4, AF_IP4);
 }
 
-VLIB_NODE_FN (udp6_encap_node) (vlib_main_t * vm,
-				vlib_node_runtime_t * node,
-				vlib_frame_t * frame)
+VLIB_NODE_FN (udp6o4_encap_node)
+(vlib_main_t *vm, vlib_node_runtime_t *node, vlib_frame_t *frame)
 {
-  return udp_encap_inline (vm, node, frame, 1);
+  return udp_encap_inline (vm, node, frame, AF_IP4, AF_IP6);
+}
+
+VLIB_NODE_FN (udp4_encap_node)
+(vlib_main_t *vm, vlib_node_runtime_t *node, vlib_frame_t *frame)
+{
+  return udp_encap_inline (vm, node, frame, AF_IP4, N_AF);
+}
+
+VLIB_NODE_FN (udp6o6_encap_node)
+(vlib_main_t *vm, vlib_node_runtime_t *node, vlib_frame_t *frame)
+{
+  return udp_encap_inline (vm, node, frame, AF_IP6, AF_IP6);
+}
+
+VLIB_NODE_FN (udp4o6_encap_node)
+(vlib_main_t *vm, vlib_node_runtime_t *node, vlib_frame_t *frame)
+{
+  return udp_encap_inline (vm, node, frame, AF_IP6, AF_IP4);
+}
+
+VLIB_NODE_FN (udp6_encap_node)
+(vlib_main_t *vm, vlib_node_runtime_t *node, vlib_frame_t *frame)
+{
+  return udp_encap_inline (vm, node, frame, AF_IP6, N_AF);
 }
 
 /* *INDENT-OFF* */
+VLIB_REGISTER_NODE (udp4o4_encap_node) = {
+  .name = "udp4o4-encap",
+  .vector_size = sizeof (u32),
+  .format_trace = format_udp4_encap_trace,
+  .n_next_nodes = 0,
+};
+
+VLIB_REGISTER_NODE (udp6o4_encap_node) = {
+  .name = "udp6o4-encap",
+  .vector_size = sizeof (u32),
+  .format_trace = format_udp6_encap_trace,
+  .n_next_nodes = 0,
+  .sibling_of = "udp4o4-encap",
+};
+
 VLIB_REGISTER_NODE (udp4_encap_node) = {
   .name = "udp4-encap",
   .vector_size = sizeof (u32),
-
   .format_trace = format_udp4_encap_trace,
+  .n_next_nodes = 0,
+  .sibling_of = "udp4o4-encap",
+};
 
+VLIB_REGISTER_NODE (udp6o6_encap_node) = {
+  .name = "udp6o6-encap",
+  .vector_size = sizeof (u32),
+  .format_trace = format_udp6_encap_trace,
+  .n_next_nodes = 0,
+};
+
+VLIB_REGISTER_NODE (udp4o6_encap_node) = {
+  .name = "udp4o6-encap",
+  .vector_size = sizeof (u32),
+  .format_trace = format_udp4_encap_trace,
   .n_next_nodes = 0,
+  .sibling_of = "udp6o6-encap",
 };
 
 VLIB_REGISTER_NODE (udp6_encap_node) = {
   .name = "udp6-encap",
   .vector_size = sizeof (u32),
-
   .format_trace = format_udp6_encap_trace,
-
   .n_next_nodes = 0,
+  .sibling_of = "udp6o6-encap",
 };
 /* *INDENT-ON* */
 
diff --git a/src/vnet/udp/udp_inlines.h b/src/vnet/udp/udp_inlines.h
index e4eb0c88e..d79dc9a2b 100644
--- a/src/vnet/udp/udp_inlines.h
+++ b/src/vnet/udp/udp_inlines.h
@@ -97,14 +97,20 @@ ip_udp_fixup_one (vlib_main_t * vm, vlib_buffer_t * b0, u8 is_ip4)
 }
 
 always_inline void
-ip_udp_encap_one (vlib_main_t * vm, vlib_buffer_t * b0, u8 * ec0, word ec_len,
-		  u8 is_ip4)
+ip_udp_encap_one (vlib_main_t *vm, vlib_buffer_t *b0, u8 *ec0, word ec_len,
+		  ip_address_family_t encap_family,
+		  ip_address_family_t payload_family)
 {
-  vnet_calc_checksums_inline (vm, b0, is_ip4, !is_ip4);
+
+  if (payload_family < N_AF)
+    {
+      vnet_calc_checksums_inline (vm, b0, payload_family == AF_IP4,
+				  payload_family == AF_IP6);
+    }
 
   vlib_buffer_advance (b0, -ec_len);
 
-  if (is_ip4)
+  if (encap_family == AF_IP4)
     {
       ip4_header_t *ip0;
 
@@ -127,21 +133,27 @@ ip_udp_encap_one (vlib_main_t * vm, vlib_buffer_t * b0, u8 * ec0, word ec_len,
 }
 
 always_inline void
-ip_udp_encap_two (vlib_main_t * vm, vlib_buffer_t * b0, vlib_buffer_t * b1,
-		  u8 * ec0, u8 * ec1, word ec_len, u8 is_v4)
+ip_udp_encap_two (vlib_main_t *vm, vlib_buffer_t *b0, vlib_buffer_t *b1,
+		  u8 *ec0, u8 *ec1, word ec_len,
+		  ip_address_family_t encap_family,
+		  ip_address_family_t payload_family)
 {
   u16 new_l0, new_l1;
   udp_header_t *udp0, *udp1;
+  int payload_ip4 = (payload_family == AF_IP4);
 
   ASSERT (_vec_len (ec0) == _vec_len (ec1));
 
-  vnet_calc_checksums_inline (vm, b0, is_v4, !is_v4);
-  vnet_calc_checksums_inline (vm, b1, is_v4, !is_v4);
+  if (payload_family < N_AF)
+    {
+      vnet_calc_checksums_inline (vm, b0, payload_ip4, !payload_ip4);
+      vnet_calc_checksums_inline (vm, b1, payload_ip4, !payload_ip4);
+    }
 
   vlib_buffer_advance (b0, -ec_len);
   vlib_buffer_advance (b1, -ec_len);
 
-  if (is_v4)
+  if (encap_family == AF_IP4)
     {
       ip4_header_t *ip0, *ip1;
       ip_csum_t sum0, sum1;
diff --git a/src/vnet/vxlan-gpe/encap.c b/src/vnet/vxlan-gpe/encap.c
index daa0381c4..35a5529e8 100644
--- a/src/vnet/vxlan-gpe/encap.c
+++ b/src/vnet/vxlan-gpe/encap.c
@@ -88,13 +88,15 @@ format_vxlan_gpe_encap_trace (u8 * s, va_list * args)
  *
  */
 always_inline void
-vxlan_gpe_encap_one_inline (vxlan_gpe_main_t * ngm, vlib_buffer_t * b0,
-			    vxlan_gpe_tunnel_t * t0, u32 * next0, u8 is_v4)
+vxlan_gpe_encap_one_inline (vxlan_gpe_main_t *ngm, vlib_buffer_t *b0,
+			    vxlan_gpe_tunnel_t *t0, u32 *next0,
+			    ip_address_family_t af)
 {
   ASSERT (sizeof (ip4_vxlan_gpe_header_t) == 36);
   ASSERT (sizeof (ip6_vxlan_gpe_header_t) == 56);
 
-  ip_udp_encap_one (ngm->vlib_main, b0, t0->rewrite, t0->rewrite_size, is_v4);
+  ip_udp_encap_one (ngm->vlib_main, b0, t0->rewrite, t0->rewrite_size, af,
+		    N_AF);
   next0[0] = t0->encap_next_node;
 }
 
@@ -112,16 +114,18 @@ vxlan_gpe_encap_one_inline (vxlan_gpe_main_t * ngm, vlib_buffer_t * b0,
  *
  */
 always_inline void
-vxlan_gpe_encap_two_inline (vxlan_gpe_main_t * ngm, vlib_buffer_t * b0,
-			    vlib_buffer_t * b1, vxlan_gpe_tunnel_t * t0,
-			    vxlan_gpe_tunnel_t * t1, u32 * next0,
-			    u32 * next1, u8 is_v4)
+vxlan_gpe_encap_two_inline (vxlan_gpe_main_t *ngm, vlib_buffer_t *b0,
+			    vlib_buffer_t *b1, vxlan_gpe_tunnel_t *t0,
+			    vxlan_gpe_tunnel_t *t1, u32 *next0, u32 *next1,
+			    ip_address_family_t af)
 {
   ASSERT (sizeof (ip4_vxlan_gpe_header_t) == 36);
   ASSERT (sizeof (ip6_vxlan_gpe_header_t) == 56);
 
-  ip_udp_encap_one (ngm->vlib_main, b0, t0->rewrite, t0->rewrite_size, is_v4);
-  ip_udp_encap_one (ngm->vlib_main, b1, t1->rewrite, t1->rewrite_size, is_v4);
+  ip_udp_encap_one (ngm->vlib_main, b0, t0->rewrite, t0->rewrite_size, af,
+		    N_AF);
+  ip_udp_encap_one (ngm->vlib_main, b1, t1->rewrite, t1->rewrite_size, af,
+		    N_AF);
   next0[0] = next1[0] = t0->encap_next_node;
 }
 
@@ -170,7 +174,7 @@ vxlan_gpe_encap (vlib_main_t * vm,
       u32 sw_if_index0 = ~0, sw_if_index1 = ~0, len0, len1;
       vnet_hw_interface_t *hi0, *hi1;
       vxlan_gpe_tunnel_t *t0 = NULL, *t1 = NULL;
-      u8 is_ip4_0 = 0, is_ip4_1 = 0;
+      ip_address_family_t af_0 = AF_IP4, af_1 = AF_IP4;
 
       vlib_get_next_frame (vm, node, next_index, to_next, n_left_to_next);
 
@@ -201,7 +205,7 @@ vxlan_gpe_encap (vlib_main_t * vm,
 	  n_left_to_next -= 2;
 	  n_left_from -= 2;
 
-	  /* get the flag "is_ip4" */
+	  /* get "af_0" */
 	  if (sw_if_index0 != vnet_buffer (b[0])->sw_if_index[VLIB_TX])
 	    {
 	      sw_if_index0 = vnet_buffer (b[0])->sw_if_index[VLIB_TX];
@@ -210,10 +214,10 @@ vxlan_gpe_encap (vlib_main_t * vm,
 					   vnet_buffer (b[0])->sw_if_index
 					   [VLIB_TX]);
 	      t0 = pool_elt_at_index (ngm->tunnels, hi0->dev_instance);
-	      is_ip4_0 = (t0->flags & VXLAN_GPE_TUNNEL_IS_IPV4);
+	      af_0 = (t0->flags & VXLAN_GPE_TUNNEL_IS_IPV4 ? AF_IP4 : AF_IP6);
 	    }
 
-	  /* get the flag "is_ip4" */
+	  /* get "af_1" */
 	  if (sw_if_index1 != vnet_buffer (b[1])->sw_if_index[VLIB_TX])
 	    {
 	      if (sw_if_index0 == vnet_buffer (b[1])->sw_if_index[VLIB_TX])
@@ -221,7 +225,7 @@ vxlan_gpe_encap (vlib_main_t * vm,
 		  sw_if_index1 = sw_if_index0;
 		  hi1 = hi0;
 		  t1 = t0;
-		  is_ip4_1 = is_ip4_0;
+		  af_1 = af_0;
 		}
 	      else
 		{
@@ -231,19 +235,20 @@ vxlan_gpe_encap (vlib_main_t * vm,
 					       vnet_buffer (b[1])->sw_if_index
 					       [VLIB_TX]);
 		  t1 = pool_elt_at_index (ngm->tunnels, hi1->dev_instance);
-		  is_ip4_1 = (t1->flags & VXLAN_GPE_TUNNEL_IS_IPV4);
+		  af_1 =
+		    (t1->flags & VXLAN_GPE_TUNNEL_IS_IPV4 ? AF_IP4 : AF_IP6);
 		}
 	    }
 
-	  if (PREDICT_TRUE (is_ip4_0 == is_ip4_1))
+	  if (PREDICT_TRUE (af_0 == af_1))
 	    {
 	      vxlan_gpe_encap_two_inline (ngm, b[0], b[1], t0, t1, &next0,
-					  &next1, is_ip4_0);
+					  &next1, af_0);
 	    }
 	  else
 	    {
-	      vxlan_gpe_encap_one_inline (ngm, b[0], t0, &next0, is_ip4_0);
-	      vxlan_gpe_encap_one_inline (ngm, b[1], t1, &next1, is_ip4_1);
+	      vxlan_gpe_encap_one_inline (ngm, b[0], t0, &next0, af_0);
+	      vxlan_gpe_encap_one_inline (ngm, b[1], t1, &next1, af_1);
 	    }
 
 	  /* Reset to look up tunnel partner in the configured FIB */
@@ -325,7 +330,7 @@ vxlan_gpe_encap (vlib_main_t * vm,
 	  n_left_from -= 1;
 	  n_left_to_next -= 1;
 
-	  /* get the flag "is_ip4" */
+	  /* get "af_0" */
 	  if (sw_if_index0 != vnet_buffer (b[0])->sw_if_index[VLIB_TX])
 	    {
 	      sw_if_index0 = vnet_buffer (b[0])->sw_if_index[VLIB_TX];
@@ -336,10 +341,10 @@ vxlan_gpe_encap (vlib_main_t * vm,
 
 	      t0 = pool_elt_at_index (ngm->tunnels, hi0->dev_instance);
 
-	      is_ip4_0 = (t0->flags & VXLAN_GPE_TUNNEL_IS_IPV4);
+	      af_0 = (t0->flags & VXLAN_GPE_TUNNEL_IS_IPV4 ? AF_IP4 : AF_IP6);
 	    }
 
-	  vxlan_gpe_encap_one_inline (ngm, b[0], t0, &next0, is_ip4_0);
+	  vxlan_gpe_encap_one_inline (ngm, b[0], t0, &next0, af_0);
 
 	  /* Reset to look up tunnel partner in the configured FIB */
 	  vnet_buffer (b[0])->sw_if_index[VLIB_TX] = t0->encap_fib_index;
diff --git a/src/vpp-api/vapi/vapi_c_gen.py b/src/vpp-api/vapi/vapi_c_gen.py
index 100263ccb..b86115893 100755
--- a/src/vpp-api/vapi/vapi_c_gen.py
+++ b/src/vpp-api/vapi/vapi_c_gen.py
@@ -648,22 +648,6 @@ class CMessage (Message):
         ])
 
 
-vapi_send_with_control_ping = """
-static inline vapi_error_e
-vapi_send_with_control_ping (vapi_ctx_t ctx, void *msg, u32 context)
-{
-  vapi_msg_control_ping *ping = vapi_alloc_control_ping (ctx);
-  if (!ping)
-    {
-      return VAPI_ENOMEM;
-    }
-  ping->header.context = context;
-  vapi_msg_control_ping_hton (ping);
-  return vapi_send2 (ctx, msg, ping);
-}
-"""
-
-
 def emit_definition(parser, json_file, emitted, o):
     if o in emitted:
         return
@@ -746,6 +730,8 @@ def gen_json_unified_header(parser, logger, j, io, name):
         print("")
         print("static inline vapi_error_e vapi_send_with_control_ping "
               "(vapi_ctx_t ctx, void * msg, u32 context);")
+    elif name == "vlib.api.vapi.h":
+        print("#include <vapi/memclnt.api.vapi.h>")
     else:
         print("#include <vapi/vlib.api.vapi.h>")
     print("")
@@ -775,7 +761,21 @@ def gen_json_unified_header(parser, logger, j, io, name):
     print("")
 
     if name == "vlib.api.vapi.h":
-        print("%s" % vapi_send_with_control_ping)
+        vapi_send_with_control_ping_function = """
+static inline vapi_error_e
+vapi_send_with_control_ping (vapi_ctx_t ctx, void *msg, u32 context)
+{
+  vapi_msg_control_ping *ping = vapi_alloc_control_ping (ctx);
+  if (!ping)
+    {
+      return VAPI_ENOMEM;
+    }
+  ping->header.context = context;
+  vapi_msg_control_ping_hton (ping);
+  return vapi_send2 (ctx, msg, ping);
+}
+"""
+        print("%s" % vapi_send_with_control_ping_function)
         print("")
 
     print("#ifdef __cplusplus")
diff --git a/test/test_udp.py b/test/test_udp.py
index df9a0af3b..818510555 100644
--- a/test/test_udp.py
+++ b/test/test_udp.py
@@ -145,25 +145,30 @@ class TestUdpEncap(VppTestCase):
             [VppRoutePath("0.0.0.0",
                           0xFFFFFFFF,
                           type=FibPathType.FIB_PATH_TYPE_UDP_ENCAP,
-                          next_hop_id=udp_encap_0.id)], table_id=1)
+                          next_hop_id=udp_encap_0.id,
+                          proto=FibPathProto.FIB_PATH_NH_PROTO_IP4)],
+            table_id=1)
         route_4o6 = VppIpRoute(
             self, "1.1.2.1", 32,
             [VppRoutePath("0.0.0.0",
                           0xFFFFFFFF,
                           type=FibPathType.FIB_PATH_TYPE_UDP_ENCAP,
-                          next_hop_id=udp_encap_2.id)])
+                          next_hop_id=udp_encap_2.id,
+                          proto=FibPathProto.FIB_PATH_NH_PROTO_IP4)])
         route_6o4 = VppIpRoute(
             self, "2001::1", 128,
             [VppRoutePath("0.0.0.0",
                           0xFFFFFFFF,
                           type=FibPathType.FIB_PATH_TYPE_UDP_ENCAP,
-                          next_hop_id=udp_encap_1.id)])
+                          next_hop_id=udp_encap_1.id,
+                          proto=FibPathProto.FIB_PATH_NH_PROTO_IP6)])
         route_6o6 = VppIpRoute(
             self, "2001::3", 128,
             [VppRoutePath("0.0.0.0",
                           0xFFFFFFFF,
                           type=FibPathType.FIB_PATH_TYPE_UDP_ENCAP,
-                          next_hop_id=udp_encap_3.id)])
+                          next_hop_id=udp_encap_3.id,
+                          proto=FibPathProto.FIB_PATH_NH_PROTO_IP6)])
         route_4o6.add_vpp_config()
         route_6o6.add_vpp_config()
         route_6o4.add_vpp_config()
